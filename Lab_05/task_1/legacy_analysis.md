# Анализ устаревшего кода (Appendix A)

## 1. Использование `var` для объявления переменных
**Проблема:** В коде повсеместно используются переменные `var` (например, строки 4, 5).
**Почему это плохо:** 
- `var` имеет функциональную область видимости, а не блочную. Это значит, что переменная может "вытекать" за пределы циклов `for` или блоков `if`.
- `var` подвержен "всплытию" (hoisting), что позволяет использовать переменную до её объявления, порождая трудноуловимые баги.
- Он не защищает от повторного объявления (можно случайно создать две переменные с одним именем).

## 2. Загрязнение глобальной области видимости
**Проблема:** Весь код (константы `taxRate`, функции `Product`, `Cart`) находится в общем глобальном пространстве имен.
**Почему это плохо:** 
- Если подключить другой JS-файл, где есть переменная с таким же именем, произойдет конфликт.
- Код сложно тестировать и поддерживать, так как зависимости между частями неявные.

## 3. Использование функций-конструкторов и прототипов
**Проблема:** Классы реализованы через `function Product(...)` и `Cart.prototype.method = ...`.
**Почему это плохо:** 
- Синтаксис разрозненный: конструктор описывается в одном месте, а его методы — в других частях файла.
- Это выглядит сложнее для чтения и понимания структуры объекта по сравнению с современным синтаксисом `class`.

## 4. Отсутствие инкапсуляции (приватности)
**Проблема:** Все свойства объектов, такие как `this.items` в корзине или `this.price` в товаре, являются публичными.
**Почему это плохо:** 
- Внешний код может напрямую изменить содержимое корзины (например, `cart.items = []`), минуя логику приложения. Это нарушает целостность данных. В современном JS для этого должны использоваться приватные поля (`#`).

## 5. Устаревший синтаксис строк и функций
**Проблема:** 
- Используется конкатенация строк через оператор `+` (строка 34, 40).
- Используются только обычные функции `function`, даже там, где уместны стрелочные.
**Почему это плохо:** 
- Конкатенация строк менее читаема, чем шаблонные строки (Template Literals).
- Обычные функции имеют свой контекст `this`, что часто приводит к ошибкам при работе с колбэками (хотя в данном примере это не критично, это антипаттерн для современного JS).

## 6. Отсутствие модульности
**Проблема:** Код представляет собой один монолитный скрипт.
**Почему это плохо:** 
- Логика конфигурации (налоги), утилиты (форматирование) и бизнес-логика (корзина) перемешаны. Это затрудняет повторное использование кода.